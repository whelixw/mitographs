rule fna_to_circ_vg:
    input:
        "data/{sample}.fna"
    output:
        "results/{sample}_circ.vg"
    shell:
        """
        vg construct -r {input} > {wildcards.sample}_circ.vg
        vg circularize -p {wildcards.sample} {wildcards.sample}_circ.vg > {output}
        """

rule vg_make_reference_map:
    input:
        vg="results/{sample}_circ.vg"
    output:
        xg="intermediate/{sample}_circ.xg",
        gcsa="intermediate/{sample}_circ.gcsa"
    params:
        vg_pruned="intermediate/{sample}_circ_pruned.vg"  # Using a separate directory for intermediate files
    shell:
        """
        vg index -x {output.xg} {input.vg}
        vg prune -k 48 {input.vg} > {params.vg_pruned}
        vg index -g {output.gcsa} {params.vg_pruned}
        """

rule vg_map_query:
    input:
        ref_vg="results/{ref}_circ.vg",
        ref_xg="intermediate/{ref}_circ.xg",
        ref_gcsa="intermediate/{ref}_circ.gcsa",
        query_fasta="data/{query}.fna"
    output:
        gfa="results/{ref}@{query}_map.gfa"
    params:
        query_str="intermediate/{query}_str",
        map_gam="intermediate/{ref}_{query}_circ_map.gam",
        aug_vg="intermediate/{ref}_{query}_circ_map.vg"
    log:
        "logs/{ref}_{query}_mapping.log"
    shell:
        """
        tail -n +2 {input.query_fasta} | tr -d '\n' > {params.query_str} 2>> {log}
        vg map -s $(cat {params.query_str}) -V {wildcards.query} -x {input.ref_xg} -g {input.ref_gcsa} > {params.map_gam} 2>> {log}
        vg augment -i -S {input.ref_vg} {params.map_gam} > {params.aug_vg} 2>> {log}
        vg convert -f {params.aug_vg} > {output.gfa} 2>> {log}
        """

rule vg_construct_giraffe_reference:
    input:
        ref_vg="results/{ref}_circ.vg"
    output:
        gfa="results/{ref}@circ_gf.gfa",
        xg="results/{ref}@circ_gf.xg",
        gbz="results/{ref}@circ_gf.giraffe.gbz",
        min="results/{ref}@circ_gf.min",
        dist="results/{ref}@circ_gf.dist"
    shell:
        """
        vg convert -f {input.ref_vg} > {output.gfa}
        vg convert {input.ref_vg} -x > {output.xg}
        vg autoindex -p {wildcards.ref}@circ_gf -w giraffe -g {output.gfa}
        mv {wildcards.ref}@circ_gf* results
        """
rule vg_giraffe_align:
    input:
        xg="results/{ref}@circ_gf.xg",
        gbz="results/{ref}@circ_gf.giraffe.gbz",
        min="results/{ref}@circ_gf.min",
        dist="results/{ref}@circ_gf.dist",
        query_fq="data/{sample}.fq",
	sample_vg="results/{sample}_circ.vg",
	reference_vg="results/{ref}_circ.vg"
    output:
        gam="results/{ref}@{sample}_aligned.gam",
        vg="results/{ref}@{sample}_gf.vg",
        gfa="results/{ref}@{sample}_gf.gfa"
    params:
        ref_name=lambda wc: wc.ref.replace("_circ", ""),  # Adjust the sample name here
        sample_name=lambda wc: wc.sample.replace("_circ", "")
    shell:
        """
        # Use {params.ref_name} to reference the corrected sample name within your shell commands
        vg giraffe -x {input.xg} -g {input.gbz} -m {input.min} -d {input.dist} -f data/{params.sample_name}.fq > {output.gam}
        vg augment -i -S results/{params.ref_name}_circ.vg {output.gam} > {output.vg}
        vg convert -f {output.vg} > {output.gfa}
        """

rule vg_giraffe_align_long:
    input:
        xg="results/{ref}@circ_gf.xg",
        gbz="results/{ref}@circ_gf.giraffe.gbz",
        min="results/{ref}@circ_gf.min",
        dist="results/{ref}@circ_gf.dist",
        query_fq="data/{sample}.fq",
        sample_vg="results/{sample}_circ.vg",
        reference_vg="results/{ref}_circ.vg"
    output:
        gam="results/{ref}@{sample}_aligned.gam",
        vg="results/{ref}@{sample}_gfc.vg",
        gfa="results/{ref}@{sample}_gfc.gfa"
    params:
        ref_name=lambda wc: wc.ref.replace("_circ", ""),  # Adjust the sample name here
        sample_name=lambda wc: wc.sample.replace("_circ", "")
    shell:
        """
        # Use {params.ref_name} to reference the corrected sample name within your shell commands
        vg giraffe -x {input.xg} -g {input.gbz} -m {input.min} -d {input.dist} -f data/{params.sample_name}.fq > {output.gam} --align-from-chains
        vg augment -i -S results/{params.ref_name}_circ.vg {output.gam} > {output.vg}
        vg convert -f {output.vg} > {output.gfa}
        """

 
rule spoof_fq:
    input:
        fna="data/{sample}.fna"
    output:
        fq="data/{sample}.fq",
    shell:
        """
	seqtk seq -F 'I' {input.fna} > {output.fq}
        """

rule smoothix:
    input:
        gfa="results/{sample}.gfa"
    output:
        gfa="results/{sample}_sm.gfa"
    shell:
        """
        smoothxg -g {input.gfa} -o {output.gfa}
        """
