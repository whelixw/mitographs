rule fna_to_circ_vg:
    input:
        "data/{sample}.fna"
    output:
        "results/{sample}_circ.vg"
    shell:
        """
        vg construct -r {input} > {wildcards.sample}_circ.vg
        vg circularize {wildcards.sample}_circ.vg > {output}
        """

rule vg_make_reference_map:
    input:
        vg="results/{sample}_circ.vg"
    output:
        xg="intermediate/{sample}_circ.xg",
        gcsa="intermediate/{sample}_circ.gcsa"
    params:
        vg_pruned="intermediate/{sample}_circ_pruned.vg"  # Using a separate directory for intermediate files
    shell:
        """
        vg index -x {output.xg} {input.vg}
        vg prune -k 48 {output.vg} > {params.vg_pruned}
        vg index -g {output.gcsa} {params.vg_pruned}
        """

rule vg_map_query:
    input:
        ref_vg="results/{ref}_circ.vg",
        ref_xg="results/{ref}_circ.xg",
        ref_gcsa="results/{ref}_circ.gcsa",
        query_fasta="data/{query}.fna"
    output:
        gfa="results/{ref}@{query}_circ_map.gfa"
    params:
        query_str="intermediate/{query}_str",
        map_gam="intermediate/{ref}_{query}_circ_map.gam",
        aug_vg="intermediate/{ref}_{query}_circ_map.vg"
    log:
        "logs/{ref}_{query}_mapping.log"
    shell:
        """
        tail -n +2 {input.query_fasta} | tr -d '\n' > {params.query_str} 2>> {log}
        vg map -s $(cat {params.query_str}) -x {input.ref_xg} -g {input.ref_gcsa} > {params.map_gam} 2>> {log}
        vg augment -i -S {input.ref_vg} {params.map_gam} > {params.aug_vg} 2>> {log}
        vg convert -f {params.aug_vg} > {output.gfa} 2>> {log}
        """

rule vg_construct_giraffe_reference:
    input:
        ref_vg="results/{ref}_circ.vg"
    output:
        gfa="results/{ref}@circ_gf.gfa",
        xg="results/{ref}@circ_gf.xg",
        gbz="results/{ref}@circ_gf.giraffe.gbz",
        min="results/{ref}@circ_gf.min",
        dist="results/{ref}@circ_gf.dist"
    shell:
        """
        vg convert -f {input.ref_vg} > {output.gfa}
        vg convert {input.ref_vg} -x > {output.xg}
        vg autoindex -p {wildcards.ref}@circ_gf -w giraffe -g {output.gfa}
        mv {wildcards.ref}@circ_gf* results
        """
rule vg_giraffe_align:
    input:
        xg="results/{ref}@circ_gf.xg",
        gbz="results/{ref}@circ_gf.giraffe.gbz",
        min="results/{ref}@circ_gf.min",
        dist="results/{ref}@circ_gf.dist",
        #vg=lambda wildcards: f"results/{wildcards.ref}@circ_gf.vg"
        query_fq="data/{ref}.fq"
    output:
        gam="results/{ref}@{sample}_aligned.gam",
        vg="results/{ref}@{sample}_gf.vg",
        gfa="results/{ref}@{sample}_gf.gfa"
    params:
        vg_path=lambda wildcards: f"results/{wildcards.ref}@circ_gf.vg"
    shell:
        """
        vg giraffe -x {input.xg} -g {input.gbz} -m {input.min} -d {input.dist} -f {input.query_fq} > {output.gam}
        vg augment -i -S {params.vg_path} {output.gam} > {output.vg}
        vg convert -f {output.vg} > {output.gfa}
        """
 
rule spoof_fq:
    input:
        fna="data/{sample}.fna"
    output:
        fq="data/{sample}.fq",
    shell:
        """
	seqtk seq -F 'I' {input.fna} > {output.fq}
        """
